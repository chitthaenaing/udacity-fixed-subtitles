01 - 콘텐츠 제공자
======================

이제 우리는 데이터베이스를 가지고 있는지 우리가 취할 수있는
에 대한 우리의 견해를 바인딩 Android 패턴의 장점
콘텐츠 공급자로 알려진 우리의 데이터 모델. 콘텐츠
공급자는 우리는 우리의 뷰 데이터를 생각할 수 있습니다
편리한 구조이다 URI의 조건
우리의 응용 프로그램.우리는 뷰 기반의 다른 데이터를 표시 할 수 있습니다
게다가 URI가 현재 활성화이다. 결국,
URI는 그 의도에 대한 주요 데타메 멤버이며,
라토는 매우 훌륭하게 설명되어있다. 조합
콘텐츠 제공자의 의도의 1이 잘 할 수
뷰에서 표시되는 데이터를 분리한다.그리고 우리는에서 파생 한 다른 좋은 점은 있습니다
데이터 위치에서 URI를 사용합니다. 그것은 간단합니다
우리의 데이터베이스가 등록되어있는 컴퍼넌트에 통지하고 있기 때문에
우리의 커서의 원인과 그 위치를 관찰
우리의 목록을 업데이트하고 최신 데이터를 표시합니다.
콘텐츠 공급자는 모든 종류의 데이터를 반환 할 수 있지만, 일반적으로 그들은 어느 쪽이든을 돌려 준다
항목 목록 또는 단일 품목.여기에 하나는 우리를 변경하는 방법입니다
특정 날짜의 데이터를 선택하는 쿼리가 아닌 범위
이 경우에도 시청자가 볼 수있는 더 많은 정보가 포함되어 있습니다 날.


02 - 왜 콘텐츠 제공자 물질
=================================

우리는 가서 콘텐츠 프로 바이더를 구축하기 전에
당신은 왜 묻기 위하여 라인 밖에서는 없습니다.가장 간단한 대답은 당신이 할 수있는 것입니다
응용 프로그램의 경계를 넘어 안전하고 효율적으로하여 데이터를 공유
기본 데이터 소스를 추상화하는 그것을 좋아 SQLite 수
이 파일 또는 정말 뭔가. 그래서 다른
응용 프로그램은 정말 방법을 이해할 필요없이 액세스 할 수 있습니다
당신은 그것을 저장되었습니다. 사실, 달력, SMS, 연락처
API는 공유 콘텐츠 공급자를 사용하여 이러한 동작.우리는 나중에 우리의 기상 데이터베이스를 공유하려고하고 있습니다 만, 만약 당신이
당신이하고있는 앱의 데이터를 공개하는 것을 계획하고 있지 않다
아마 당신은 오른쪽이 비트를 건너 뛸 수 있습니다 생각하십니까? 그런데,
대부분 당신은 가능성이 많은 경우
그러나 실제로는 말라. 예를 들어, 선샤인 년에 사용하는
SQ 라이트.그러나 당신이에 데이터를 저장할 수 있었다
파일은 동적 런타임 데이터 또는 단순히 다른
데이터베이스 라이브러리. 콘텐츠 공급자를 사용함으로써 더 용이하다
당신은 잠재적으로 데이터 소스를 전환과
당신이 관리하는 것 이외의 누군가를 위해 훨씬 더 쉽게
그들을 이해하지 않아도, UI 레이어 코드
당신의 데이터 스토리지 구현의 깊이.위
UI 계층은 그것은 커서를 반환 범용 메커니즘입니다.
SQLite 데이터베이스에서 반환 된 것과 같다. 그래서,
당신의 데이터 계층의 구현이 변경되었을 경우 귀하의 콘텐츠 공급자
진행된다. 그래도 그것만으로는 코드의 권리를 쓰고있다
지금, 그것은을 위해 상투적가 많아요
깔끔한 디자인 패턴은 다음.그런데, 사실을 기억
한 틀에 관해서는 모든 데이터가 처리됩니다
콘텐츠 제공자 통해. 그래서, 당신은과 상호 작용하는 경우
이러한 데이터를 전송하도록 응용 밖에는 아무것도,
위젯 이후 응용 프로그램에서 검색 결과를 반환 당신이 필요합니다
너무 따라서 콘텐츠 제공자. 사실, 그것이 어떻게했다
Google 플레이 스토어와 Gmail 위젯의 일.과
구글 플레이에서 검색 결과를 얻을 수있는 기능. 마찬가지로 무리가 있습니다
싱크 데이터를 조회하는 과정을 최적화하도록 설계된 API의
이에 따라 UI를 업데이트한다. 그들 모두는 콘텐츠 제공자가 기대된다.
즉, 동기화 어댑터와 커서 로더가 포함되어 있습니다.어떻게 당신을 만든다
효율적인 서버 부하 데이터와 동기화 할 수 리케이션
당신의 UI 계층 및 그것이 포함 된 콘텐츠의 관측에 지어
때 기본 데이터의 변경을 자동으로 UI를 업데이트합니다.당신
물론, 모든 것을 스스로 구축했지만 아니었다
당신이 쓰지 않는 것으로 얻을 수있는 장점이있는 점
과정에서 손실로 시작 컨텐츠 공급자
그것을 이용하여 편리한 클러스터의 모든 것을 다시 창조한다.
우리는 당신의 콘텐츠 제공자를 공개하고 Lotus를 사용하여보고하자
이 단원에서는 효율적으로 나중에에 액세스합니다.그리고 우리는 동기화 어댑터를 찾아갑니다
레슨 6 년에는 효율적인 백그라운드 업데이트를 가본 때. 그러나
먼저 댄 실제로 컨텐츠 프로 바이더를 구축하는 방법을 보여 드리려고합니다.


03 - 콘텐츠 공급자 만들기
================================

이러한 필요와 콘텐츠 제공자 함수입니다.당신
그들을 원하는대로 구현할 수 있지만,
당신이 정직은 정말 다 볼 수 있습니다
SQLite 데이터베이스에이를 구현한다. 더
우리의 콘텐츠 제공자 함수 경기 팩 파라미터
Android의 SQLite의 인터페이스에 사용되는 파라미터 대부분
정확하게. 가장 큰 차이점은 우리가 대체하는 것입니다
URI를 표 string ,.가장 단순
콘텐츠 프로 바이더의 구현은 쿼리가 전달 된
바로 데이터베이스에 이른다. 양해 바랍니다
쉽게하실 수 없습니다 매개 변수가 있습니다
이러한 기능을 그룹화하는 등 콘텐츠 제공자,을 통해 제어.
그러나 인터페이스는 매우 유연한 쿼리를 가능하게합니다.
가장 중요한 것은, 돌기 또는 열 검색 처리를
훨씬 더 효율적이다.칼럼 위해
인덱스와 우리의 커서 객체의 일치 투영
우리는 우리 만있는 데이터베이스에 제출
대신, 그들의 숫자 인덱스 값을 가져
각을 조회하기위한 getColumnIndex를 사용할 필요가
열 인덱스. 모든 권리, 그것은 일부를 코딩하는 때가왔다
더 선샤인. 는 콘텐츠 제공자를 코딩하고 보자.04 - 우리의 계약에 콘텐츠 공급자 추가
============================================

우리는 콘텐츠 제공자의 작성을 시작하기 전에
그것은 우리의 날씨에 돌아 오는 시간이다
계약. 우리는 날씨 계약을 사용하는거야,
데이터베이스 정의와 콘텐츠 제공자의 정의 모두를 위해.
이들은 우리의 계약은 데이터 및 뷰에 대한 공개합니다 URI이다. 일부
그들은 항목의 목록 또는 디렉토리를 돌려 준다.그 중 일부는 단일 항목으로 돌려 준다.
URI의 첫 번째 부분은 어떻게 시스템 인 콘텐츠의 권위이다
마찬가지로, 다른 응용 프로그램에서 URI를 명확
도메인 이름과 웹 사이트 사이의 관계.
콘텐츠에 사용하는 편리한 문자열
당국은 앱의 패키지 이름입니다.
우리의 기상 계약으로 돌아가 보자. 우리는 추가합니다
우리의 콘텐츠 CONTENT_AUTHORITY과 BASE_CONTENT_URI
우리 날씨의 선두에 공급자
계약.그렇다면, 우리는베이스에 문자열을 추가합니다
우리의 URI 경로. 각 URI는 기본적으로 지적
다른 테이블에. 우리의 각각에 대해
테이블 위치 항목 및 기상 항목은 우리
각 테이블의 기본 위치를 나타내는 콘텐츠의 URI를 만듭니다. 그런데,
우리는 장소와 날씨 항목 계약에 어떤 마법의 값을 추가합니다.이들은한다는 특수한 MIME 유형의 접두사가 포함되어있는
URI는 어느 쪽인지는 항목의 목록을 디렉토리를 반환
또는 단일 아이템. 그런데, 우리는 몇 가지를 추가하는거야
날씨 항목의 URI 빌더와 디코더 기능. 그것은이다
그것은 더 적은 공간을 만들기로 이것을 가지고있는 것이 편리
실제 URI 인코딩을 인식하고 당신의 코드에서
계약이 지식을 유지한다.당신 뿐이라면
표준 정수 URI를 가질거야
구별 전형적인 방법이다 기본 키
항목 또는 목록 쿼리의 쿼리
항목 1은 특허받은 컨텐츠의 URI를 사용할 수 있습니다
ID 기능. 그런 위치 설정 등의 문자열과 수
아뻰도빠스 기능을 추가했다. 우리는 또한 이러한 수 있습니다
잠재적으로 유용한 쿼리 매개 변수를 추가 할 수있는 기능입니다.이 경우
우리는 시작일 쿼리 매개 변수를 사용합니다. 쿼리
매개 변수, 우리는 고정 데이터베이스를 가지고있을 때 유용합니다
우리는 일부 제한된 매개 변수를 갖게하는 쿼리
위해. 이 경우에는 매개 변수입니다
우리 두 테이블 간의 조인. 마지막으로, 우리는있다
포함하는 2 부 URI를 구축합니다. 이 기능
장소와 날짜의 두 세그먼트.이 아래에, 우리는 가지고있다
URI 구조를 디코딩 봉사 도우미 함수. 이것은 숨길 수 있습니다
URI의 구조뿐만 아니라 코드를 형성하고,
계약의 한 곳에서 모든 지식을 배치합니다. 05 - ID UriBuilder에서 LocationEntry 추가
============================================

조회하기위한 URI를 구축하기 위해 코드를 추가합니다.
WeatherContract의 LocationEntry 부분의 ID로 장소.06 - LocationEntry 솔루션을 추가
==================================

모든 권리 완료되었습니다! 그러면 솔루션을 살펴 봅시다. 이 연습
상당히 짧습니다. 그리고 그것은 다만 방법 우리처럼 보이는
빌드 날씨 URI 이전했다. 다시 한번, 우리 만
레코드 ID를 추가하기 위해서는 특허 ID로 컨텐츠 URI를 사용합니다.


07 - WeatherProvider을 만듭니다.
===========================

그럼 이내에 날씨 프로 바이더 클래스를 만들어 보자
데이터 패키지.우리는 그것이 컨텐트 프로 바이더를 확장해야합니다. [SOUND]
당신은 제목에 따라 필요한 메소드를 가질 수 있습니다
Ctrl 키를 + 나는 다시. 콘텐츠 공급자에 따라 기능을 구현하는
URI의. 각 URI 유형은 연결되어
정수. 우리의 콘텐츠 공급자는 5 개를 실시한다
URI의 다른 유형. 이들 각각
URI 쿼리의 종류에 사용됩니다.지금은 단지 우리의 날씨 공급자 클래스에 이러한 상수를 추가 할 수 있습니다.
Android는 돕기 위해 URI 매핑 처 클래스를 제공합니다
우리의 정수로 URI와 일치한다. 그것은 제공하고 있습니다
다양한 URI에 따라 표현의 구문을 위해.
이제 이들은 예입니다. 당신이 필요로하는
곧 이들 중 하나를 실시한다. 주의 사항
2 와일드 카드가 있어야합니다.파운드 기호
스타 문자열을 일치시키는 데 사용되는 동안 수를 일치시키는 데 사용된다. 이것을 사용하여
당신은 매우 쉽게 URI의 중 하나와 일치 할 수 있습니다
우리는 콘텐츠 공급자에게 전달하고 싶은 것을.


08 - UriMatcher 쓰기
=========================

우리 콘텐츠의 URI 앞에 설명은
나는 우리가 사용하는 5 URI 유형을 보여 주었다
이 앱은 빌드 URI에 필요 사항을 기입
매치 기능.당신은 여전히​​이를 테스트 할 수 없다는 점에 유의하십시오.


09 - UriMatcher 쓰기
=========================

모든 권리는 완료되었습니다. 나는 당신에게 내 솔루션을 보여 보자.
우리는 하늘의 URI 정규 표현 엔진을 작성하는 것부터 시작. 나는 루트 노드가 일치 할 필요는 없습니다
아무거나. 이것은 전형적인 동작입니다. 있도록하려면
읽기 코드보다 쉽게​​, 내가 바로 가기를 만들고 있어요
날씨 계약 내용 당국에.기술적으로는 날짜
항상 수치가됩니다 만, 나는 일치하지
스타의 경로는 그들이에 저장되어 있기 때문에
문자열로 우리의 데이터베이스는, 다만 일치하도록.
마지막으로, 우리는 장소의 URI를 가지고있다. 데이터베이스의 ID이기 때문에
항상 정수 그것은 숫자 기호 패턴을 사용하도록 완벽한 의미가있다.
이제 우리는 우리의 클래스 변수를 추가 할 수 있습니다.[BLANK_AUDIO}


10 - UriMatcher 쓰기
=========================

모든 권리는 완료되었습니다. 나는 당신에게 내 솔루션을 보여 보자.
우리는 하늘의 URI 정규 표현 엔진을 작성하는 것부터 시작. 나는 루트 노드가 일치 할 필요는 없습니다
아무거나. 이것은 전형적인 동작입니다. 있도록하려면
읽기 코드보다 쉽게​​, 내가 바로 가기를 만들고 있어요
날씨 계약 내용 당국에.기술적으로는 날짜
항상 수치가됩니다 만, 나는 일치하지
스타의 경로는 그들이에 저장되어 있기 때문에
문자열로 우리의 데이터베이스는, 다만 일치하도록.
마지막으로, 우리는 장소의 URI를 가지고있다. 데이터베이스의 ID이기 때문에
항상 정수 그것은 숫자 기호 패턴을 사용하도록 완벽한 의미가있다.
이제 우리는 우리의 클래스 변수를 추가 할 수 있습니다.[BLANK_AUDIO}


11 - 콘텐츠 공급자 코딩
================================

당사는 콘텐츠 공급자를 코딩을 시작하기 전에 해 봅시다
매니페스트가 제대로 설정되어 있는지 확인하십시오.
당신 이내에 AndroidManifest.xml 파일을 업데이트해야합니다
콘텐츠 공급자를 추가하기위한 응용 프로그램 태그입니다. 이렇게
그 Android의 컨텐츠 확인자는 그것을 볼 수 있습니다. 더
당국은 정말 당신의 패키지 이름과 일치해야합니다. 동시에
이름은 콘텐츠 공급자를 제출 한 것을 보여
클래스이다. 다음은 생성에 코딩 봅시다.우리는 우리를 위해 인스턴스 변수를 만들고 시작하자
데이터베이스 도우미. 위의 작성, 우리는 인스턴스 변수를 시작한다.
우리는 안드로이드를 가르치는 방법이다 true를 반환
콘텐츠 제공자가 성공적으로 작성되었습니다. 그것은 밝혀
우리는 우리가 만든 동일한 테스트를 재사용 할 수
데이터베이스에 대한 우리의 새로운 콘텐츠 공급자를 테스트합니다.이
당신은 모두 당신의 콘텐츠 제공자의 코드를 테스트 할 수 있습니다
콘텐츠 공급자 호출이 SQLI을 바꾸는 방법을 확인
데이터베이스 호출. 는 Android를 사용하자
Studio는 테스트 제공자에 TestDB 및 복사합니다.
는 DB를 삭제 테스트하기 위해 DB를 생성하고 테스트의 이름을 변경하여 봅시다.
그래서 우리는 백지 상태에서 시작할 수 있습니다.우리는 다만 도트 삭제 M 컨텍스트를 남겨 둡니다
거기에서 데이터베이스 라인. 우리는 서로를 남겨 둡니다
동일한 테스트를, 우리는 즉시 그것을 가져옵니다.


12 -의 ContentProvider의 getType 코딩
===================================

는 콘텐츠 제공자의 코딩로 돌아가 보자. 첫
우리가 구현하려고하는 필요한 콘텐츠 제공자 기법
의 getType있다.의 getType는 MIME 타입을 반환하는 데 사용되는
지정된 URI에있는 데이터와 관련된있다. 우리는 사용
URI 녹차는 우리는 주어진과 일치하도록 이전에 구축
우리가 컴파일했다. 각 경기의 식에 대해 URI,
우리는 어느 쪽인지로 시작 독특한 마임 시간을 반환
싱글 음반의 V와 D의 Android 커서 항목 또는
여러 항목에 대한 V와 D의 Android 커서 DIR.우리는 깨끗하게 이미 우리의 WeatherContract 이러한 문자열을 정의했습니다
우리의 테스트에서 우리는 타입을 취득하고있다. 우리는 작곡거야
URI는 내부에, 우리는 표준 방법을 사용하여 우리의
WeatherContract. 그럼 우리가 두에서 이들을 통과거야
ContentResolver의 통해 콘텐츠 공급자. 어떤 방법을 설명하고있다
콘텐츠 공급자의 모든 함수를 호출합니다.그리고 우리는거야
그것은 우리가 계약을 가지고있는 것과 일치하는지 확인하십시오.
당신이 있기 때문에 내가 코멘트로 실제 값을 배치 한
무슨 일이 일어나고 있는지, 정말을 참조하십시오. 이들 중 일부는 다시 점에 유의하십시오
그들은 목록을 반환거야 의미 유형의 디렉토리
그들의 커서의 다른 아이템.다른 사람은 형태를 돌려주는하는 동안
그들은 단일 항목을 반환하는 것을 의미 아이템.
그렇다면, 우리는 당신이의 getType을 끝낼 필요가 있다고하고있다. 당신은 추가거야
이 switch 문장의 적절한 예. 그러나 마임을 갚기 위해
종류, 우리는 아직 처리하지 않은 나머지 URI 타입. 아니,
그들은 거기에 추가하는 유일한 2가 있고
정말 그냥 WeatherContract의 것 같이 보인다.13 - 콘텐츠 공급자 쿼리 코딩
======================================

우리의 콘텐츠 공급자를 코딩 계속합시다. 쿼리는 다음과 같습니다
필요한 콘텐츠 제공자 방법의 가장 복잡한.
우리는 쿼리 작업의 뼈에서 시작된다.
우리는 다시 우리의 스리 맵 차트 개체를 사용
URI 유형 전환합니다.이것은
우리는 작성해야 할 것이다 유일한 기능
콘텐츠 프로 바이더의 URI의 모든 유형. 일부
그 유일한 질의에 사용된다. 우리는 구현합니다
첫 번째 기본적인 기상 쿼리 이 쿼리는 우리
단순한 매개 변수를 모두 통과
데이터베이스. 매우 간단한 것. 그럼 그렇게 이러한 매개 변수를 수정합시다
그들은 어떤 의미를 이룬다.그래서 여기에 문자열이
실제로 예상. S는 선택이다. 다음
배열은 selectionArgs입니다. 마지막 문자열 정렬한다
매우 잘 일치 한 순이었다. 하단에
기능 때문에 우리는 알림을 설정하는거야
함수에 전달 된 것에 우리의 커서 URI.
이 콘텐츠 옵저버를 등록하기 위해 커서를 일으킨다. 그 변화를 감시하기 위해
그 URI에 일어나면 그 자손 중 하나. 자손에 의해
나는이 경로로 시작하는 URI를 의미한다.그러나 우리는 아직 이것을 테스트해야합니다. 14 - CodingContentProviderqueryTestDELETE
=========================================

는 사용하는 테스트 삽입 REDV 테스트를 업데이트하세요
일기 예보를 얻으려면 날씨 공급자를 사용하는
쿼리. 우리는 테스트의 이름을 변경하는 것으로 시작하자,
읽기 공급자를 삽입합니다.우리가 할 필요가 있으므로 모든
있는 책 dv 쿼리를 가지고 그것을 대체
콘텐츠를 수신하여이를 해당 콘텐츠 제공자 하나
확인자 및 콘텐츠의 URI를 조회합니다. 그런데,
콘텐츠 제공자는 한쪽이 이러한 매개 변수 중 일부를 가지고 가지 않는다.
그것은 암묵적 그래서 예를 들어, 그것은 TABLE_NAME를 가지고 가지 않는다
URI를 지정하고 또한 그 그룹을 지원하지 않습니다.그것의 나머지 부분은 꽤 잘 작동합니다. 그런데,
테스트를 실행하고 그것이 통과하는 것을 확인하자.
[BLANK_AUDIO]
그리고 테스트는 여전히 통과. [LAUGH] 역시 대용하는 것은 매우 간단합니다
콘텐츠 공급자를 사용하여 데이터베이스에 직접 호출 뭔가 출.


15 - 장소와 위치 -ID를 구현
=======================================

위치 및 위치 ID로 문의를 구현
우리의 콘텐츠 공급자.URI가 포함되어있는 내용에주의하십시오
그것의 끝에 ID가 포함되어있는 표준 URI에서 ID를 검색하는 기능.


16 - 위치 -ID 솔루션을 구현
===================================

모든 권리는 완료되었습니다. 그럼 살펴 보자
솔루션. 할 수 있도록, 우리는 이전 그만두고
우리는 LOCATION_ID위한 2 개의 빈 쿼리를 가지고 참조하십시오.
LOCATION.이러한 두 개의 쿼리가 쿼리의 많은 것을보고
우리는 날씨에있다. LOCATION_ID 내용은 이것은 거의 보이지
정확하게 우리는 날씨에 무엇을 해야할지처럼. 우리가 사용하는 경우를 제외하고
하드 코딩 된 쿼리가 아닌 1에 의존
함수에 전달되었다. 우리는 이것이다는 것을 알고 있기 때문에
항상 긴 정수라고하는 것이다
단순히 쿼리 문자열 값을 구축하기 쉽다.위치
한편, 거의 정확하게 날씨처럼 보이는
쿼리. 우리는 단지 데이터베이스에 모든 매개 변수를 전달합니다. 당신
당신이 테스트없이 멀리 얻을 거라고는 생각하지 않았다 당신이 했어?
그것이이 테스트를 추가하는 것은 매우 간단하다, 걱정하지 마십시오. 그것은 턴
공급자 이내에 당사의 함수를 호출하면 대부분 작동하는 수
우리는 날씨 테이블을 실시한 방법과 동일.우리가해야하는 것은에서 WeatherEntry.CONTENT_URI를 교환합니다
LocationEntry.CONTENT_URI. 물론, 우리는 여전히 제거해야
우리가 지원할 수 없습니다 하나의 라인. 지금은 정말 의지
작품. 그러면 그것이 작동하는지 확인하기 위해 테스트 봅시다.
예상대로 그리고 우리의 테스트는 통과되었다. 약 흥미롭게
이 테스트는 그냥에만 첫 번째 테스트하다는 것입니다
우리는 삭제 되었기 때문에, 쿼리, 그냥 작동하게 일어나는
시작하기 전에 데이터베이스.그것은 훨씬 더 재미있을 것이다
우리 방금 삽입 된 행에 대한 조회한다. 그리고 이것은 테스트합니다
다른 쿼리. 그럼 테스트를 다시 실행하여 보자. 그리고 그들에 합격했습니다. 그래서 우리는있다
우리의 내용에서 우리 쿼리의 일부
공급자 기능한다. 그러나 불행히도 우리는 아직있다
더 복잡한 여러하려면
공급자의 것.조인에 대해 이야기합시다. 17 - 쿼리를 등록하고
=====================

우리는 먼저 우리 테이블을 정의 할 때, 우리는 정의 된
제약 측면에서의 관계. 이제 우리
우리에게 그 관계를 구현하려고하고있다
이것은 조인을 사용하여 쿼리가 우리를 할 수 있습니다
에서의 값의 날씨 테이블을 조회하는
특정 위치 설정.우리는 추가하는 것부터 시작하자
에서 SQL ITE 쿼리 작성기 클래스 변수
날씨 공급자의 탑. 우리는에 SQLI를 초기화합니다
정적 생성자 쿼리 빌더
클래스 두 테이블 간의 조인 기술한다. 주의 사항
두 테이블은 _ID라는 열을 가지고 있기 때문이다.
우리는 명시 적으로 테이블 이름을 사용해야합니다
우리는 밑줄 ID 명확히하기 위해
참여하는 이야기.그럼 우리가 할 수있는
쿼리를 정의한다. 쿼리는 찾을 수 있습니다
물음표 교환 구문을 사용합니다. 이러한 물음표
쿼리 매개 변수로 대체합니다. 우리 때문에
사람들은 URI에 시작 날짜를 지정할 수 있으며,
우리는 또한 포함 두 번째 선택을 추가하는거야
날짜 텍스트가보다 큰지 여부를 확인하거나
우리의 매개 변수와 같다.그렇다면, 우리는에 메서드를 추가합니다
같은 쿼리를 사용하여 위치 항목에서 날씨를 얻을
빌더. 우리는 우리의 URI에서 파라미터를 취득하는 점에 유의하십시오.
그리고 문자열 배열이 그들이 할당 할 수
우리 쿼리. URI는 시작일이 포함되어 있지 않은 경우, 우리가 실제로 사용하는 것에주의하십시오
다른 선택. 마지막으로, 기능을 추가
우리의 컨텐트 프로 바이더 쿼리 루틴.18 - 참여 우리의 테스트
=====================

이제 우리는 이것을 테스트해야합니다. 그럼으로 돌아 가자
다시 테스트 제공. 그것은 우리의 테스트를 파라미터 화하면 편리 하겠지요
좀 더, 장소 및 날짜 둘.
판권 지금 우리는 우리의 테스트를 파라미터 화했기 때문에 반환합시다
우리의 삽입에 찾아 제공자를 읽어 보시기 바랍니다.날씨 때문에,
우리는 현재 쿼리 원시 콘텐츠의 URI를 사용하고있다. 그러나 우리
또한 추가 데이터를 조회 할 수 있습니다. 복사 및 붙여 넣기하여
이 텍스트는 우리는 다른 쿼리 매개 변수를 사용하여 텍스트를 시도 할 수 있습니다.
그것은 좋은 것이다, 그래서 우리는 커서를 닫습니다
연습. 현재 우리의 두 번째 기상 쿼리,
우리는 첫 번째 테스트를하는거야
우리의 새로운 URI : WeatherEntry.buildweatherlocation 우리가 사용 할 수 있습니다
우리의 새로운 작업 위치 매개 변수입니다. 자, 가자
이 테스트를 실행하여보십시오. 그리고 우리의 테스트
전달되었다. 그런데 그런데. 우리는 1보다 많은 것을 추가하는거야
쿼리에 경미한 변동과 테스트
시작에서 날씨의 위치를​​ 구축 사용하여
날짜 대신. 그래서 우리는 시험에 사용하는거야
장소뿐만 아니라 시험 날짜.그리고 지금은 이러한 테스트를 실행하자. 과
우리의 테스트를 통과. 그런데 가끔은이다
실제로 테스트 실패를 나타내는데 유용한.
우리는 것입니다 20150624., 것은 확실하게 실패하는 일 날짜를 넣어 봅시다
이 테스트가 실패하는 것을 기대하고 있습니다. 는 그것을 시도하자 실제로 그것이 실패합니다. 이렇게
우리의 테스트는 실제로 우리는 그들을 기대하고 무엇을하고 있는지 확신하고있다.


19 - 기타 참여 쿼리 퀴즈를 추가합니다.
==================================

괜찮아. 당신이 무엇인지 시간을 알고있다.쿼리를 구현하기위한 시간
우리의 콘텐츠 제공자의 LOCATION과 날짜 WEATHER 위하여. 기억, 우리는 정의 된
우리 중 URI에서 위치 문의와 데이트를위한 함수
날씨 계약. 또한 당신은 대답 쓰기를 얻었다 확인하는 테스트를 작성합니다.


20 - 기타 결합 질의 솔루션을 추가합니다.
======================================

괜찮아. 당신이 완료됩니다. 그러면 솔루션을 살펴 봅시다. 모든
맞아.우리는 WeatherProvider로 이동합니다. 우리가 만드는 것부터 시작
우리의 공급자 상단의 第三の選択 쿼리 업,
우리는 검색하는 것을 제외하고는 제 2의 쿼리와 같은 많은
정확한 날짜. 더 오히려 이상
날짜 우리는 다음의 날씨를 사용하는 함수를 추가
계약. 에서 날짜와 우편 번호를 취득하기위한 함수
URI. 우리는 우리가 방금 쓴 새 쿼리를 사용하고 있습니다.그리고 그것은 단지 참여를 규정하고 있기 때문에, 우리는 이전에 사용한 것과 같은 SQLI 쿼리 빌더.
그리고 우리는이 함수를 호출
우리 안에 장소와 날짜 switch 문과의 날씨
쿼리. 그래서 끝. 이들은 모든 쿼리들입니다
선샤인를 위해 사용하는 것을 계획했지만, 우리는 여전히해야
테스트. 테스트 공급자로 돌아가 보자.당신과
볼 수 있습니다, 우리의 테스트는 매우 좋은 모델을 가지고
이미. 이러한 이전 테스트의 일부를 수정하자
기상 커서를 닫습니다. 이제 우리는 그냥 복사 할 수 있습니다
이 테스트 오버. 그것은 정확한 것으로 판명
동일한 데이터가 우리의 새로운 URI를 위해 필요로된다.모든
우리가해야 할 것은 날씨의 위치를​​ 구축하는 것입니다
날짜 대신 시작에 날씨의 위치를​​ 말해 그리고
날짜, 우리는 같은 결과를 얻을 수 있습니다. 하자
그것은 우리의 테스트를 실행하여 정말 사실인지 여부를 확인합니다.
[SOUND] 그리고 우리의 테스트를 통과했습니다. 그래서 우리는 지금 구현했습니다
쿼리의 모든, 우리는 우리 때문에하지 않은
아직 컨텐츠 제공자.결국, 우리는 쓰지 않는
우리의 콘텐츠 공급자를 통해 데이터베이스에 모든 데이터


21 - 기타 결합 질의 솔루션을 추가합니다.
======================================

괜찮아. 당신이 완료됩니다. 그러면 솔루션을 살펴 봅시다. 모든
맞아. 우리는 WeatherProvider로 이동합니다.우리가 만드는 것부터 시작
우리의 공급자 상단의 第三の選択 쿼리 업,
우리는 검색하는 것을 제외하고는 제 2의 쿼리와 같은 많은
정확한 날짜. 더 오히려 이상
날짜 우리는 다음의 날씨를 사용하는 함수를 추가
계약. 에서 날짜와 우편 번호를 취득하기위한 함수
URI. 우리는 우리가 방금 쓴 새 쿼리를 사용하고 있습니다.그리고 그것은 단지 참여를 규정하고 있기 때문에, 우리는 이전에 사용한 것과 같은 SQLI 쿼리 빌더.
그리고 우리는이 함수를 호출
우리 안에 장소와 날짜 switch 문과의 날씨
쿼리. 그래서 끝. 이들은 모든 쿼리들입니다
선샤인를 위해 사용하는 것을 계획했지만, 우리는 여전히해야
테스트. 테스트 공급자로 돌아가 보자.당신과
볼 수 있습니다, 우리의 테스트는 매우 좋은 모델을 가지고
이미. 이러한 이전 테스트의 일부를 수정하자
기상 커서를 닫습니다. 이제 우리는 그냥 복사 할 수 있습니다
이 테스트 오버. 그것은 정확한 것으로 판명
동일한 데이터가 우리의 새로운 URI를 위해 필요로된다.모든
우리가해야 할 것은 날씨의 위치를​​ 구축하는 것입니다
날짜 대신 시작에 날씨의 위치를​​ 말해 그리고
날짜, 우리는 같은 결과를 얻을 수 있습니다. 하자
그것은 우리의 테스트를 실행하여 정말 사실인지 여부를 확인합니다.
[SOUND] 그리고 우리의 테스트를 통과했습니다. 그래서 우리는 지금 구현했습니다
쿼리의 모든, 우리는 우리 때문에하지 않은
아직 컨텐츠 제공자.결국, 우리는 쓰지 않는
우리의 콘텐츠 공급자를 통해 데이터베이스에 모든 데이터


22 - 콘텐츠 제공자의 삽입 코딩
==========================================

그것은 훌륭한이지만, 우리는 우리의 데이터베이스를 조회 할 수 있음
경우 콘텐츠 제공자를 통해 그것이 좋을 것이다
우리는 또한두기 위하여 콘텐츠 공급자를 사용 할 수 있습니다
내부 데이터.우리는 insert 함수에서 시작하자. 기입 해 봅시다
같은 URI 매핑 처 코드 삽입 기능
우리는 다른 콘텐츠 제공자의 기능이 아니라하고 있었다
1 변경. 우리는베이스와 일치하는거야
의 URI. 따라서 충분한 이유가 있습니다. 우리는 삽입하면
우리의 데이터베이스에 우리가 모든 것을 통지하고 싶다
우리의 것으로 변경된 데이터를 가지고 있을지도 모른다 콘텐츠 관측
삽입합니다.이것은 커서가 같이 자신을 등록 밝혀
루트를 통지하는 것을 의미하는 자손을 위해 통보
URI. 우리는 또한 그 URI의 모든 자손을 알려줍니다.
우리는 다른 무엇에 따라 통지 한 경우
루트 URI가 아닌. 그 후 커서 듣기
루트 URI 하가 통지되지 않습니다
확실히 그것에 영향을 미칠 수 변화한다. 그래서 우리는해야
그렇게 할 때 매우주의하십시오.이러한 이유로된다
오직 우리의 삽입을 가능하게하기 위해 많은 의미
우리의 데이터베이스에 루트 URI입니다. 그러면 그것은 매우 간단합니다
통지를 처리​​한다. 그것은 우리는 또한 가지고 있지 않다는 것을 의미합니다
우리의 삽입을위한 조합 쿼리를 구축한다. 매개 변수를 포함
URI에서 온다. 파라미터의 나머지 부분과
기능에서 온다.그래서 날씨 때문에 우리는 그냥 통과
데이터베이스 삽입 호출에 매개 변수를 설정합니다. 우리는해야
삽입이 실패했을 경우에 예외를 throw. 더
유일한 여기의 트릭은 우리를 확인하는 것입니다
URI에서 올바른 값을 반환한다. 다행히
우리는이 URI를 구축하는 기능을 만들어
이것은 계속되는 날씨 경로가 포함되어있다
ID. 작업 짓을 보자. 다시 우리
테스트 업체로 이동하여 우리의 테스트를 변경합니다.결국 그것은 테스트 삽입하게되어 있기 때문에,
제공자를 읽어 보시기 바랍니다. 여기에 우리의 insert 문입니다. 분명히, 그것은 아직 이야기
데이터베이스에. 우리는 그것을 만들기 위해거야
공급자에게 말한다. 언제나처럼, 그것은 매우 정직입니다.우리는 항상 콘텐츠를 사용하여 우리의 공급자를 취득
확인자 우리는이 INSERT 문을 대체 할 수 있습니다
대신 콘텐츠 확인자와 데시벨. 물론
우리는 테이블 이름에 대한 내용 확인자를 사용하지 마십시오.
대신, 우리는 WeatherEntry.content URI에 할거야.
하지만 아직 뭔가 잘못 있습니다. 물론 우리
실제로 기상 행 ID를 반환하지 않습니다, 우리
URI를 돌려 준다. 그러나 우리는 아직 얻을 수 있습니다
기상 행 ID. 우리는 그것을 어떻게해야합니까?
간단히 말하면. 컨텐츠 도우미 기능을 사용하여
URI, 그리고 우리는 정말 그 삽입을 필요로하지 않습니다.
결국, 우리는 알고있다. 이 컨텐츠 확인자 기능
실제로 값이 true가 아니면 반환 생각은 없다.지금은 우리
테스트를 실행하자 것을 마쳤다. 그리고 우리가 실제로 할 수 있는지 확인하십시오
우리의 콘텐츠 공급자를 사용하여 삽입합니다. 그리고 우리의 테스트를 통과했습니다. 글쎄, 당신은 무엇을 알고 있습니다
그것은 시간. 당신도이 어떤을 설명하는 시간. 23 -의 ContentProvider 완료 삽입 코딩
============================================

삽입 컨텐츠 제공 방법의 나머지 부분을 구현한다.핸들
위치 URI. 그리고 모든 등록 된 Contentobserver에 통지
변경. 그것은 당신이 할 수있는 것을 알고 당신을 도울지도 모른다
의 getContext () getContentResolver ().notifyChange (URI, null)를 사용합니다
등록 된 모든 관찰자에게 통지한다.


24 -의 ContentProvider 완료 삽입 코딩
============================================

장소 인서트를위한 지원을 추가, 거의 보이지
날씨에 대한 지원을 추가하는 것과. 우리는 다만있다
오른쪽의 테이블 이름 및 반환을 선택
적당한 장소의 URI. 그러나 또 있습니다
할 수 없습니다. 우리가해야 할 것입니다
의 getContext ().getContentResolver ()를 호출합니다. notifyChange에
실제로 전달 된 URI
우리의 함수. 필요한 모든 옵저버에 알리려면
UI가 변경된 것을 알고있다. 그리고 그 것이다.
우리는 지금 삽입을 마쳤다. 하지만 당연하게도,
우리는 또한 테스트를 추가하지 않고 해본 적이 없다하고있다.25 -의 ContentProvider 완료 삽입 코딩
============================================

장소 인서트를위한 지원을 추가, 거의 보이지
날씨에 대한 지원을 추가하는 것과. 우리는 다만있다
오른쪽의 테이블 이름 및 반환을 선택
적당한 장소의 URI. 그러나 또 있습니다
할 수 없습니다. 우리가해야 할 것입니다
의 getContext ()를 호출합니다. getContentResolver (). 위 notifyChange
실제로 전달 된 URI
우리의 함수.필요한 모든 옵저버에 알리려면
UI가 변경된 것을 알고있다. 그리고 그 것이다.
우리는 지금 삽입을 마쳤다. 하지만 당연하게도,
우리는 또한 테스트를 추가하지 않고 해본 적이 없다하고있다.


26 -의 ContentProvider 테스트 코딩
=======================================

그래서 다시, 우리는 1을 교환하는거야
아직 있는지, 우리의 테스트의 일부를 나머지
표준 데이터베이스.는 실제로 우리의 데이터베이스를 제거합시다.
즉,이 고독한 insert 문을 우리에게 남겨합니다. 한때
다시 다른 모든 것과 같이, 우리는 그것을 교환하는거야
콘텐츠 확인자 호출. 물론 우리는하고있다
실제로 테이블을 삽입 할 생각은 없다. 우리는 거 다
콘텐츠의 URI를 삽입한다. 널을 제거합니다.
물론 이것은 위치 행 ID를 반환하지 않습니다.
괜찮아요.우리는 URI에서 그것을 이끌어 낼 수 있습니다. 사용법
컨텐츠 URI, 우리는 떠날 수 있기 때문에 도우미 함수
그것은 필요하지 않지만, 그것은 거기에 삽입합니다. 과
모든 나머지는 꽤 맘에 있어야
항상있다. 우리는 더 이상 완전한 데이터베이스를 사용하지 않고있다
테스트 업체에서하지만 완전히 콘텐츠 공급자를 사용합니다.우리의 테스트를 실행하고 그들은 여전히​​ 작동하는 경우를 살펴 보자.
[BLANK_AUDIO]
그리고 그들은 모두 합격. 축하합니다, 우리는 지금
있는 완전한 기능을 갖춘 콘텐츠 공급자를 가지고
모두의 삽입 및 쿼리 물론,
당신이 원한다면이 다른 것이 있습니다
콘텐츠 제공자이다. 그런데, 우리가 아닌
실제로 이들 중 하나를 사용하는 것
선샤인에서.하지만 아는 것은 정말 중요합니다. 그래서, 당신은 실제로 이러한 기능을 구현하고 제안한다.


27 - 업데이트 및 삭제
==========================

업데이트, 삭제 방법은 많은 것 같은데
그들은 업데이트, 삭제 중 실제로 수익을 제외하고 메서드를 삽입
완료되면 URI가 대신 행 수에 영향.또한 당신이 그것을하고있는 동안 우리의 ContentObservers에 통지하는 것을 확인하십시오


28 - 업데이트 및 삭제 솔루션
===================================

모든 권리는 완료되었습니다. 그럼 살펴 보자
솔루션. 삭제 실제로는 매우 간단합니다.
다시 우리는 거의 쓸모가있는 것에주의하십시오
파라미터.우리 안에 S는 실제로 우리의 선택을 의미
여기서 문자열은 실제로 우리의 선택 루피이다. One
삭제는 대부분 기책은 실제로 당신의 경우 것입니다
에서 아무것도 선택에 넣지 않은 그것은 모든 행을 삭제합니다.
난 아직도 우리가 변화를 통지하는 것을 확인하고 싶다.
나는 여기에서 슬라이드의 최적화를 실시 해왔다.그것은 그렇게됩니다
그냥 항상 변경을 통지하지만, 나는 결정 벌금
행이 삭제되지 않은 경우, 우리는해야
통지가 아닌 느낌. 선택이 null 인 경우를 제외하고 그 속에서
경우 우리는 다시 그것을 모든 행을 삭제했지만,
괜찮다고 생각만으로도로 변경을 통지에 사용
행은 실제로 삭제되지 않는 경우. 결국 의도
행이 삭제된다는 것이었다.다시 마 십시다
당신의 코드를 유지해야하는 경우가 있습니다 누군가 그리고 변화에 동정
뭔가에 이러한 기본 매개 변수 이름
선택과 selectionargs 같은 더 편리합니다.
그렇지 않으면 업데이트는 거의 정확하게 제거처럼 보입니다. 한때
다시 말하지만, 우리는에 의해 영향을받은 행 수를 반환
업데이트, 우리가 행했을 경우에 통지 걱정하지 마십시오
영향을 받았다.이제 우리는 우리는 업데이트를 쓰 마치고 삭제 된 것
테스트 업체로 돌아가서 몇 가지 테스트를 추가 할 수 있습니다.
먼저 테스트 delete.db 의존하지 않는 마지막 테스트를 제거하자
공급자. 대신, 삭제 테스트가 봅시다
모든 기록과 검사들이 실제로 삭제하고 있는지 확인합니다.
기억, 누루쿠에리을 전달하면 실제 모두 삭제합니다
테이블의 레코드. 그래서 이것은 단순히 전달 정말 곧장 앞으로는
널.우리는 제거하기 위해 데이터베이스에 의존하고 있기 때문에 그건
우리가 실제로 삭제를 테스트하는 것이 모든 것이 특히 중요하지 않다
기능은 그것이 나중에 추가하려면 좋은 것이지만.
우리는 그것을 추가 싶습니다 이유는 그 것을 확인하는 것입니다
우리의 제약이 유효합니다. 그리고 우리는 제거하고 끝나면
우리는 왼쪽의 행이 포함되어 있지 않은지 확인하십시오.우리는 장소를 제거하기 전에 날씨 항목을 제거 할 필요가 있다는 점에 유의하십시오
항목에는 날씨 침입을 막기 데이터베이스의 제약을 가지고 있기 때문에,
위치 항목은 또한 일까에도 존재하지 않는 경우 기존의
이러한 항목의 삭제를 방지한다. 그럼 여부를 확인하자
그것은 실제로 작동합니다. 모든 권리 전달합니다. 좋은 소식.지금 우리가 할 수
우리가 할 수있는 것을 확인하고 끝까지 동일한 테스트를 추가
마지막으로 모든 행을 삭제하고 그것은 여전히​​ 작동합니다.
그리고 당신이 볼 수있는 것처럼, 그들은 여전히​​ 통과한다. 그래서 지금 우리는 알고 있었
이전과 테스트를 실행 한 후 삭제 된 레코드. 그럼 시험해 봅시다
그 갱신. 우리는 위치 그냥 업데이트 다하겠습니다.여기에서도 모든 레코드를 삭제하고 삽입하고 시작하자
우리는 업데이트 할 레코드. 약 멋진 것들 중 하나
콘텐츠의 가치는 당신이 실제로 사용하여 그들을 복사 할 수있다
복사 생성자. 그럼 우리는 ID, 우리를 추가 할 수 있습니다
업데이트 후 도시의 이름을 넣고 싶다
우리는 그것을 새롭게하고 싶다. 이 경우는 북극에서
산타 마을에. 그리고 마지막으로, 우리는 업데이트를 호출합니다.우리가 실제처럼 정확하게 하나의 레코드를 업데이트했다고 주장
우리는 기대하고 그 위에 쿼리를 실행하고자
우리의 커서를 검증 우리의 업데이트가 실제로 작동하는지 확인한다.
그리고 마지막으로, 우리는 우리의 커서를 닫습니다. 그것은 모든
꽤 좋아 보인다. 그리고는 그것이 실제로 실행되는 것을보고하자
과 오른쪽을 수행합니다. 그리고 우리의 테스트를 통과.그래서 우리는 지금 우리는 업데이트, 삭제, 삽입 할 수있는 것을 증명하고있다
과 조회 및 모든 이것은 완전히 테스트되고있다.
즉, 우리의 응용 프로그램의 뼈
다만 우리의 UI를 설치 기다리고 종료한다.
그럼 통과하고 우리의 UI의 일부를 첨부 해 봅시다.29 - 효율적인 업데이트를 삽입
==============================

그럼 우리는 당사의 컨텐츠 공급자의 코어에서 이루어지고있다,
그러나 물건을 만들어주는 1 이상의 임의의 방법은 아직 없습니다
훨씬 효율적입니다. 우리는보고 Ctrl + O를 눌러 시작합니다
기능에서, 우리는 덮어 쓸 수 있습니다. 그것은 거기 것이 판명
bulkInsert 호출되는 함수.하고있다 거기에는 누구나
데이터베이스 작업은에 삽입 잔뜩 넣고 있다는 것을 알고있다
단일 트랜잭션은 일반적으로 그들을 삽입하는 것보다 훨씬 빠릅니다
개별적으로. 대량 삽입은 우리는 바로 그것을 할 수 있습니다. 기본
구현은 단지 배를 잔뜩 삽입 호출하지만,
우리는 구현하면 우리는 트랜잭션에 포장 할 수 있습니다
그것은 자신.우리는 유일한 지원을 추가하는거야
여기에 날씨 거래 그들이 유일하다, 그래서 우리는 삽입
일괄. 우리는 db.beginTransaction를 호출하여 시작합니다. 각각에 대해
전달 된 ContentValues​​, 우리는 삽입 숫자를 업데이트
레코드가 삽입되었다. 우리가 완료되면, 우리는 트랜잭션을 설정
성공하기 위하여. 그렇지 않으면 우리의 기록은 커밋되지 않습니다,
그 후 종료 finally 문장에 의존
거래. 기본 경우, 우리는 슈퍼를 호출
클래스. 뿐만 아니라 최적으로 삽입하고, 기억하십시오.과
그거야, 우리가 bulkInsert를 구현해야하는 모두입니다.


30 -의 ContentProvider와 인서트는 DELETE
============================================

괜찮아. 그러면 심각한 동참합시다. 당사는 취득하기 위해 실제 작업을 사용하여 이동해야합니다
날씨입니다. 결국, 날씨는 심각한 사업입니다. 하자
우리의 콘텐츠 공급자에 이입하기 위해 다른 FetchWeatherTask를 작성
데이터베이스.그리고 우리는 우리의 기존의 이동하고 시작하자
이 새로운 오버 작업. 와우. 그것은 좋은
ForecastFragment에서 그 큰 작업을 가져옵니다. 과
우리는 공극의 공극 문자열 매개 변수를 변경하는거야.
아, 우리는 해결하기 위해 컴파일 오류를 많이 가지고있다. 그것은 괜찮습니다. 위해
이제 우리는 배경 부분의 관광 용 이외의 모든 것을 삭제하는거야
비동기 작업.는 그것을 생성자를주고 문맥을 건네 보자. 배경 할 때 노이즈, 위치를 오프에 저장하자
이해하기위한 코드를 촉진하기 위해 문자열로 쿼리.
그리고 재미에 대한 최대 14 일을하자
예측 데이터입니다. 우리는 일시적으로 JSON에서 기상 데이터를 검색하고 제거하기 때문에,
우리는 하단 try 캐치에서 제거 할 수 있습니다.우리는하고있다
openweather API에서 추가 데이터를 많이 찾아 간다.
이를 용이하게하기 위해, 여기에서는 문자열, 우리는 잘입니다
사용하고 있습니다. 우리는 또한 도시 이름, 위도를하고 있어요
openweather 의해 반환 경도. 이제 우리는 랩을해야한다
이것은 운동에 차례로 확인
우리는 예외를 처리합니다. 그런데 그런데. 지금 우리가 처리 한
예외는 그렇게 모두가 컴파일됩니다.그리고 좀보고, 우리는있다
도시 이름과 좌표. 흠, 우리는 지금 위치를 얻고있다
우리는 데이터베이스에 뭔가를 삽입하는 데 사용할 수있다.
그리고 우리는 잠시 이런 짓을하지 않기 때문에 프로그래밍 연습을위한 시간입니다
우리가 할 수 있습니다 전에 그것이 실제로 해 봅시다
안드로이드가 정말 컴파일 할 수 있는지 확인하십시오.그러면 예측 조각에 돌아 가자, 그리고 가지고
날씨 작업이 실행되는 인출 방법을 봐. One
그것은 날씨의 작업이 그것을 필요로하려고 페치
우리는 활동 또는 일부 다른 컨텍스트를 취득 합격
그래서 그. 우리가 할 또 한가지는있다
이러한 불쾌한 공유 환경 설정을한다. 그리고 거기에 우리가있다
그것은 우리의 우선 가져 오기 유틸리티 함수
장소.자, 이제 우리는 응용 프로그램을 실행할 준비가되었습니다
우리는 실제로 다음 연습을 할 수 있습니다. 다시 한번, 우리는 거 다
우리의 아주 새로운 페치 기상 작업에 대한 호출이기 위하여는
그것은 아무것도하지만, 몇 가지 시도 읽고 않을거야
제이슨. 그래서 우리가 그 이상의 무언가를 만들고 싶다. [SOUND]


31 -의 ContentProvider와 인서트
=====================================

괜찮아.여기에서이 즐길 수 있습니다. 코드 아래 방법
그렇지 않은 경우는 위치 테이블에 자리를 삽입하는
이미 존재하고있다. 위치 ID를 반환한다. 지금 할 수 있습니다
이날 삽입에 이어 쿼리를 사용하여 간단한 방법을 실시한다.


32 -의 ContentProvider와 인서트
=====================================

괜찮아. 당신이 완료됩니다. 그럼 내 솔루션을 살펴 보자. 괜찮아.그래서 여기에서
우리의 addLocation 기능은 locationSetting 도시 이름 어떤 것인가
위도와 경도. 다만 우리의 내용처럼
공급자 테스트, 우리는 조회 getContentResolver를 사용할 수 있습니다
컨텐츠 URI에 근거한다. 것을 잊지 마세요
기본 위치 항목 CO NTENT_URI은 모두 통과
데이터베이스 매개 변수를 설정합니다.그래서 우리는 쉽게 할 수
여부를 확인하기 위해 설정하는 장소를 포함하는 쿼리를 작성
아직 데이터베이스에 있습니다. 그렇지 않은 경우 쿼리
빈 집합을 반환하고, 우리는 새로 삽입해야합니다
도시 이름과 함께 데이터베이스에 위치 설정 위도, 경도.


33 - FetchWeatherTask 마무리
===================================

당신이주의 한대로, 우리는 실제로 테스트하지 않습니다
아직 새로운 기능.다행히도 우리는있다
백그라운드 할 때 꽤 좋은 명소
해. 결국, 바로 여기에 우리는 이미 まし했다
우리는 그 함수를 호출하는 데 필요한 모든 것을 분석되었다. 그래서 우리는 긴을 호출 할 수 있습니다
locationId는 addLocation 도시 이름 locationQuery 같다
city​​ latitude 및 citylongitude.우리의 계약을 가지고있는 것이 도움이 될 것입니다
날짜 객체로 변환하고 다르게 1
형식으로 우리의 데이터베이스를 사용하고 있습니다. 그 안드로이드에주의하십시오
스튜디오는 문제 데이터 객체를 가져 오지 수 있고
Java는 이틀 클래스 데이터베이스 중 하나를 가지고 있기 때문에,
java.util의 하나. 우리는 java.util.Date 것이 원한다. 백
FetchWeatherTask, 우리는 데이터를 수집 할거야
기상 배열에 JSON에서. 모든 권리이므로,
우리는 지금 그 데이터를 왕창 가지고
삽입 할 필요가있다. 우리는 다음의 일을하려고하는지 아세요?


34 -의 ContentProvider와 BulkInserts
=========================================

괜찮아. 이제 우리는 우리의 ContentProvider과의 대화에 다시 있기 때문에 그것은 시간이다
다른 운동을 가지고있다.사용하십시오
콘텐츠의 벡터를 삽입하는 ContentProvider
값은 데이터베이스에 개체. [LAUGH]
걱정하지 마세요, 우리는 정말 대부분에서 이루어지고있다
데이터를 삽입한다. 다음 그것, 그것은 모든 가치가 재미있는 부분입니다.


35 -의 ContentProvider와 BulkInserts
=========================================

괜찮아. 당신은 완료입니다. 갑시다
의 ContentProvider와 bulkInserts를 해결 오버.우리는 직접 벡터를 삽입 할 수 없지만, 우리는 쉽게 벡터를 변환 할 수 있습니다
배열. 우리는 이것을하는 경우
bulkInsert 법은 매우 효율적으로 삽입됩니다. 그런데,
우리의 백엔드를 효율적으로 갱신됩니다. 그러나 우리
정말 앞을 업데이트하는 방법이 필요합니다
프레임 속도 지터​​를 도입하지 않고 종료합니다. 다행히도, Android의
로더로 알려진 그 패턴을 제공합니다.36 - 로더는 대단해
========================

로더에 대해 이야기합시다. 로더는 훌륭합니다. 그들은했다
벌집에서 도입됐지만의 일부로 사용할 수 있습니다
지원 라이브러리. 그래서 그들을 사용할 수 있습니다
이전 플랫폼의 출시를 지원하기 때. 로더는 기본적으로 최고입니다
활동의 비동기 데이터로드를위한 운동의 구현
또는 조각.당신은 로더를 만들 때 그것이 만들어집니다
비동기 작업은 백그라운드 스레드에서 데이터를로드합니다.
때 초기 이후 UI 스레드와 동기화
로드가 완료하고 모니터링하도록 설정할 수 있습니다
기본 데이터 및 UI에 대한 업데이트를 제공
마찬가지로 넣습니다. 당신이 한 베스트 여전히 모든 그 일
데이터베이스에 콘텐츠 공급자를 추가 할 수있는 권리를 보상
이제 커서 로더를 가진다.커서 로더가
비동기 작업 로더의 구현은 특히 조회하도록 설계
콘텐츠 제공자, 그리고 당신이 그 수 커서를 반환
UI에 직접 결합한다. 그것은 자동으로 커서가 업데이트됩니다,
언제든지 변경에 따라 기본 콘텐츠 공급자 변경
기본 데이터베이스에. 그리고 그것은 다시 연결합니다
마지막으로 따라 재 작성된 후 커서를 반환
설정 변경 후 활동을 후원했다.당신이없는 것을 의미합니다
장치가 없었다는 이유만으로 데이터를 다시 쿼리해야
회전시켰다. 그래서 커서 로더는 커서를 모두 처리합니다
관리 및 백그라운드 스레드 생성, UI 스레드 동기화 및 데이터
소스 모니터링. 당신은 콘텐츠 공급자를 사용하지 않는 경우
당신은 나쁜 선택했습니다.그래도 당신이 사용할 수 있습니다
로더 당신은 자신을 작성해야합니다
직접 사고 작업 로더를 확장함으로써 로더. 당신
아래의 강사 노트의 세부 정보를 찾을 수 있습니다.


37 - 단점 퀴즈
=======================

안드로이드의 초기 버전은 로더를 가지고 있지 않았다
패턴.이것은 직접 조회하는 것을 피하기 위해 추가되었습니다
UI 코드에서 데이터베이스. 단점은 무엇입니까
직접 UI 코드에서 데이터베이스를 조회하는 것으로?
쿼리 시간이 오래 걸릴 수 있습니다. 그것은 수
그것이 완료되기 전에 종료한다. 또는 NO 단점은 없습니다.


38 - 단점 솔루션
===========================

나는 Android의 초기 버전, 전에 말했듯이
로더 모델을 가지고 있지 않았다.원래 비추천 모델
많은 응용 프로그램에있을 때마다 프레임 속도가 저하 원인
그들의 데이터베이스를 다시 쿼리한다. 하지만 간단한 것. 데이터베이스는 이제까지
우리가 여기에있는 것보다 복잡
선샤인. 따라서 첫 번째 대답은 분명 예수님입니다.우리는 AsyncTask 같은 것이 바인딩되어 있는지를 지적
UI 그렇게 방향성처럼 작은 선물
변경은 쿼리를 죽일 수있다. 그래서 다른 뚜렷하다
예. 그래서 세 번째 옵션은 단순히 비 스타터입니다.


39 - 우리의 응용 프로그램 로더를 사용하여
=============================

우리는 기능을 우리의 콜백 추가하는 것부터 시작합니다
우리의 예상 조각에.이제 우리는 2가 알고있는
로더 콜백을 위해 여기에서 다른 옵션. 우리가하고 싶은
우리는 그렇게 android.support.v4 콜백을 선택했는지 확인하십시오
우리는 진저와의 호환성이다. 이들은 일반적인를 가지고
타입. 우리는 커서를 사용하는거야. 그리고 이렇게
Andriod.database.cursor있다. 이제 우리 어디로 아래로 이동합시다
실제로이 코드를 삽입한다. 여기서 하단에있는
그리고 물론, 우리는 내가 실제로 삽입하기 위해 컨트롤을 사용합니다.
그리고 거기에 우리가 커서 아름다운 우리의 로더 패턴을 가지고있다.
지금, 우리를 도와 줄 것이다 어떤 일을 해. 첫
우리는 우리의 예상 조각의 선두에 열의 들리지 않음이다.이들은 우리 안에서 사용하려고하고있는 라인 인
쿼리. 기상 항목과 장소 항목을 모두 가지고 있기 때문에, 결정주의하십시오
밑줄 ID 필드, 우리는 완전히 그 ID의 우리를 수정해야합니다
이 쿼리를 실행하기 위해 우리의 투영 원한다. 그 동안
사실이 쿼리에서 작동하도록 투영을 필요로
모호한 모두, 그렇지 않으면 [UNKNOWN].그렇다면 여기에서 그 인덱스가
이러한 열과 연관된 있습니다. 이것은 몇 가지를 만들어 줄게
우리의 일 후에 더 쉽다. 이들이 실제로해야한다는 점에 유의하십시오
경기. 그럼 우리가 사용하는 일부 공공의 인덱스를 만들고
우리의 어댑터. 이것은 우리가 우리 것을 할 수 있습니다
어댑터에서 작은 및 효율적인 코드.그러나 그것을
수단, 우리는 이러한 열 인덱스와의 관계를 유지해야한다.
로 예상. 각 로​​더는 ID를 가지고 있습니다. 그
조각이 활성화 여러 로더를 가질 수
한 번. 우리는 [들리지 않는] 인스턴스와 함께 이것을 넣어하는
여기에서 우리의 위치를​​ 꺼 저장할 변수
우리 학급의 최고. 그런 우리가 무시하려고하고있다
onActivityCreated.로더가 초기화된다
onActivityCreated에서 자신의 삶을 위해
사이클은 실제로 활동에 묶여있다. 하지
fragment. 로더 ID의 사용에주의하십시오. FORECAST_LOADER.
그럼 우리가 onCreateLoader 함수로 돌아온다.
우리는 새로운 CursorLoader을 추가합니다. 이 CursorLoader는 있습니다
시작일, 열 및 정렬 등 당사의 질의,
오더. 우리의 개시일은 우리에게 진짜로이다
URI.우리의 열은 우리가 먼저 정의 된 것이며, 우리의 정렬 순서가 일어나고있다
COLUMN_DATETEXT의 오름차순으로한다. 그러면 해 보자
1 마지막 체크. 우리가하고있는 것을 확인하고 싶다
모든 지원 라이브러리 버전을 사용하여
이 클래스는, 그렇지 않으면 우리는 Android 2.3 호환성을 얻는 것은 아닙니다.


40 - 여러 텍스트보기로 이동
==================================

목록 항목의 자원 XML을 교환하십시오
단일 텍스트 필드를 나눌 것으로 예상
다음 ID를 가진 여러 필드에 잠시
거의 같은 디자인을 유지한다.당신의 점에 유의하십시오
단순히 추가 필드를 드래그 할 수 없습니다
기존 list_item_forecast 레이아웃에 그것이 포함되어 있기 때문에
추가 뷰를 추가하는 뷰 그룹이 없다는 의미 만 텍스트 뷰.
나는 list_item_forecast을 삭제하고 새로 만들 것을 권장합니다
당신은 비주얼 편집기를 사용하는 경우 파일.41 - 여러 텍스트보기로 이동
==================================

자, 당신은 완료입니다. 해결책을 살펴 보자.
이제 우리는 일부 텍스트 뷰를 필요할 것이다. 수 있습니다 우선
우리 리니어 레이아웃을보세요. 이것은 수직이다. 우리는 그것을거야
수평. 우리는거야 그 다음 일은있다
텍스트 뷰의 무리. 단지 그들을 드래그 할 수 있도록합니다.지금
우리는 우리에게 주어진 모든 사람의 ID를 가지고 있던 기억
마지막 퀴즈. 첫 번째는 목록 항목입니다
날짜 텍스트 뷰. 그리고 우리는 그것을되고 일부 텍스트를 들면
우리는 레이아웃을 배치하는 데 도움 감. 우리는 삭제하겠습니다
이 우리는 실제로 우리의 프로젝트에 제출하기 전에. 과
재미를위한 풍경으로 전환하자. 이것은 A의 것을 만들어 줄게
좀 더 읽기 쉽다.또한 다만 조금으로 확대하자.
괜찮아. 그래서 우리의 목록 항목의 날짜 텍스트 뷰입니다. 지금
오른쪽에있는 것에 우리는 다른 텍스트보기를 바란다. 우리는 디자인하고 싶기 때문에
같은 것이, 이것은 ID를 가질 필요는 없다. 당신은 우리를 기억하는 경우
디자인은 날짜를 가지고 있었다. 대시에 이어 계속
예측은 높은 계속 대시에 계속
낮은 계속 슬래시가 이어진다.그래서 이것은 다만 뷰임을 가고있다
대시가 포함되어 있습니다. 그리고 우리도 이것을 하드 코딩 할 수 있습니다. 지금, 우리는거야
그 옆에 다른 텍스트 뷰를 작성합니다. 우리의
자리 표시 자 텍스트 분명처럼 예상됩니다.
따라서 ID는 목록 항목이됩니다
텍스트 뷰를 예측했다. 이제 우리는 다른 텍스트 뷰를 필요로하고 있습니다.다시이 1, 우리는 그것을 필요로하지 않기 때문에 ID를 가지고있는 것은 아닐 것이다. 과
우리는 다른 대시를 추가합니다. 이제 우리는 실제로 있어요
높고 낮은 예상. 말하자면
23.또 다른 일반 텍스트 뷰 높은 한번 슬래시이 1
다시없는 ID를 가진다. 그리고 우리의 높은
예측은 그것이 더 나은 list_item_high_text_view 것. 마지막으로 1을 추가합니다
더 일반 텍스트 뷰. 이 1은위한 것입니다
우리의 낮은 물론, 그것이 일어나고 있다는 것을 의미
list_item_low_text_view한다. 그리고 거기에 우리는 그것을 가지고있다. 우리의 여러 텍스트
뷰 레이아웃.이제 우리는 이것을 청소하실 수 있습니다.
그러나 이것은 좋은 시작이다, 그냥 재생
우리가 요구 한 4 개의 필드. 그들은 모두이다
리니어 레이아웃의 일부. 우리는 실제로 제출하기 전에
이것은을 제외하고 모두를위한 자리 표시 자 탭을 제거 할 수 있습니다,
정적 필드.우리는 또한 이러한 하늘의 ID를 삭제해야합니다 그
실제로 중요한 것은 이러한 텍스트 뷰에서 일어나고 주셨습니다 이해한다. 그리고 거기
우리는 그것을 가지고, 그것은 적어도 당신도 당신처럼 보이는 일이에요
그것은 우리가 시작된 레이아웃과 거의 같은 보이게하고 싶은
와.물론 이러한 설계에서 야생 간다고 있지만 수 있습니다
당신은 레이아웃 편집기에서 다양한 종류로 할 수 있습니다 많이
레이아웃. 우리는 다음 장에서 그 문제에 대해 더 알고 것입니다. 좋아,
우리는 결국 우리의 UX 이것을 후크 시작하게한다. 갑시다
백 조각을 예측한다.42 - 단순 CursorAdapter
=========================

예측 조각의 내부에서, 우리는 mForecastAdaptor를 교환하는거야
에서 작동하는 간단한 커서 어댑터 포함
새로운 데이터베이스 코드 우리는 방금 추가 한. 이것은 다른 1 인
우리는 V4 버전을 사용하고 있는지 확인하고 싶다.
우리가 있습니다. 당신에서 그것을 선택하십시오
목록. 당신은 우리가 코드를 잔뜩 볼 수 있습니다
그것은 컴파일되지 않습니다.그것은 레이 어댑터의 경우에는 스위치를 들려
우리의 예측 어댑터 새로운 심플 커서 어댑터를 사용합니다. 그런데,
심플 커서 어댑터는 꽤 멋지다. 그것은 우리를 가능하게한다
우리의 데이터베이스 열을지도하기 위하여이다
직접 위젯에 우리의 기상 계약
우리의 목록 항목. 그래서 모든 것을 제외하고는 꽤 좋아 보인다
아주 컴파일되지 않습니다.우리는 이런 일을하고있다, 따라서
디테일의 활동을 시작하기 위해 출근되어 있지 않습니다.
그래서 지금은 그냥 이것을 정리하여 봅시다. 우리는 요
나중에 다시 그것을 얻을 수 있습니다. 우리는 컴파일 뭔가를 가지고있다.
하지만 우리가 먼저 뭔가를해야합니다. 우리의 경우
지금 그것을 실행 한 우리는 여전히 아무것도 얻지 않을 것이다.이유
우리는 아직 아무것도 될 것이다 왜 우리는 그렇지 않습니다
온로드 마무리로 아무것도. onloader 재설정은지도 모른다
마찬가지로 널 swapCursor을함으로써이를 완료합니다.
우리의 코드는 실제로는 지금 무엇을해야합니다. 그러면 실행하자
그것. 그리고 그것은 끔찍한 보입니다. 데이터베이스의 어떤 데 없습니다
화면하게하는 것과 같은 것을보고.우리는 몇 가지 서식 및 설정의 도움이 필요합니다. 에 대한 더 많은 기능
우리의 유틸리티 클래스입니다. 유리한 지위를 취득하는 비트를보고 있었다
거기 고독한 오른쪽? 우리를 돕기 위해, 우리는 또 다른 한개를 추가합니다
메트릭이 현재 일을 가르쳐주는 유틸리티의 기능
설정. 우리는 온도를 포맷하는 간단한 함수를 추가합니다,
우리는 날짜를 포맷하는 기능을 추가합니다.그런데,
재미있는 것은,이 날짜의 어떤합니까? 음, 우리는했습니다
두 옵션 java.util의, 또는 java.sql을 얻었다. 이 경우, 우리는 실제로
java.util 갖고 싶어하지만, 우리는 여전히 다른 도우미 함수를 놓치고있다.
우리는 DB로 변환 weatherContract에 함수를 추가합니다
과는 반대의 실제 날짜 객체에 날짜 텍스트,
기타 계약 기능. 그래서 우리는 그것을 가지고있다. 어떻게 우리
데이터베이스가 완전히 캡슐화 된 데이터를 저장하는
계약.그래서 지금 우리는 모든 것을 쿨를 가지고
것은 어떻게 우리는 실제로 그것을 사용합니까? 는 돌아가 보자
우리의 예상 조각에. 그것은 특별한 존재라고 판명
SimpleCursorAdaptor위한 콜백은 ViewBinder라고.
[BLANK_AUDIO]
단일 기능 세트 뷰 값은 뷰 바인더를 설정합니다.
그래서 셋트 뷰 값의 안쪽에, 우리는 실제로거야
우리는 그냥보고했지만 유틸리티 기능 정말 잘 사용합니다.첫째, 우리는 통계로 오프 절약 할 수 있습니다. 우리는 경우
온도 열을 사용하여, 우리는 그냥 준수
온도. 이제 우리는 setViewValue있는,의 멋진을 넣어 보자
그중 것. 당신은 우리가 isMetric을 사용하는 것을 참조하십시오.
우리의 관점에서 온도를 이입하고 있으며, 우리는 통과 할 때
우리의 새로운 Utility.formatTemperature 기능에 그것. 그 당신이 볼 수 있기 때문에,
여기에서는 이러한 열의 인덱스를 갖는 것은 우리가이 기능을 더 것이 허락
효율적이고 우리는 5 단원으로 이동하는 데 도움이됩니다.
당신이 각성 하나는 레이아웃의 높이였다이다
정말, 정말 작은. 그냥 내용을 랩 때문입니다.우리
우리의 콘텐츠를 중앙에 그것을 전달함으로써이 문제를 해결할 수 있습니다. 그리고 바이
가장 바람직하지 않은 아이템의 높이에 최소 높이를 설정한다. 이 의지
상황이 더 많은 것뿐만 아니라 조금 더 보이게
우리의 원래 레이아웃. 그럼 간단하게 살펴 보자
이 작품의 모든 것이 우리를 위해 무엇을했는지를 참조하십시오.
[BLANK_AUDIO]
즉, 좀 더 그와 같은 것이다.당신이 볼 수 있도록 이제 우리는 우리를보고있다
우리가 예상하고 원래대로 예상하고 있습니다. 우리
우리의 설정으로 이동하고 우리가 할 수 있습니다
주문형 물건을 전환, 지금 우리가있는
내가 전에 있던 같은 문제. 우리는 없다
자세한 활동에 도달하기 위해 무엇이든한다. 글쎄, 난 당신이 그것을 고칠있는 것입니다.43 - DetailActivity 우리의 호출을 수정
======================================

당겨 우리의 디테일 활동을 낼 수 의도 호출을 수정
커서에서 데이터와 우리의 서식 유틸리티 기능을 사용하여
우리의 EXTRA_TEXT 문자열을 구축. 당사는 취득하기 위해 어댑터를 사용 할 수 있습니다
우리의 커서. 이 어댑터는 우리에서 항목을 클릭하여 청취자에게 전달됩니다.44 - DetailActivity 우리의 호출을 수정
======================================

자, 당신은 완료입니다. 텍스트 주석을 제거하는 것부터 시작해 봅시다.
당신이 볼 수 있도록, 당신은 그 4 캐스트의 문자열을 필요로하는
우리의 디테일 활동에 배달한다. 그래서 무엇을 해야할지
우리는 4 캐스트의 문자열을 검색하는 데 사용? 그럼 우리는 운
여기에서 우리는 실제로 어댑터 뷰 캐스트를 받고 있기 때문이다.우리가해야하는 것은 간단한에서 그것을 캐스팅
어댑터를 커서와 우리는 커서를 얻을 수 있습니다. 우리
우리의 위치로 이동할 수 있습니다. 그럼 우리는 String.Format을 사용하실 수 있습니다
값에 따라 포맷 된 문자열을 얻을
우리의 열. 좋은 사용 다시주의하십시오
우리의 열 intendacies의. One 엔딩 중괄호와
것은 그것이 거기에 무슨 의도로 이동하자. 그리고 그 것이다.
이제 우리는 다시 그것을 클릭 할 수있는 것입니다
그리고 정말 우리의 정상적인 상세보기 갈거야.
는 그것을 시도하자.그래서 여기에 한합니다
우리의 목록보기와 우리는 바로 세부에 들어간다. 귀여운
멋지다. 그러나 여기에서는 제국에 우리의 온도 단위를 변경 한 경우
실제로는 업데이트되지 않습니다. 그 그것이 있다면 그것은 좋은 것이다
커서 모델의 동일한 종류에 따라, 우리는 여기에있다. 에서 관찰 한 무언가
콘텐츠 관찰자 실제로 업데이트 해 버린다.
[BLANK_AUDIO]
우리는 설정을 변경 한 경우.45 - 사용자는 자신의 생각을 바꿨다
================================

판권 내가 힌트를 얻는다. 당신이 실제로 원하는
이 클래스에는 다음 전에 언젠가 마무리된다
Android 릴리스가 발생합니다. 우리는 거의 완료입니다. 그래서 우리는보고
ONSTART에서 ForecastFragment에서. 우리는 실제로 부정 해왔다
비트. 우리는 ONSTART에 도착할 때마다 우리
실제로 날씨가 업데이트되었습니다. 는 그 없애 보자.이것은 실제로 사용해야 위하여 우리를 강제합니다
새로운 일기 예보를 얻기 위해 기능을 업데이트하지만 그것은 설명 도와드립니다
우리는 취향에 무엇하려고하고있는 멋진 것.
여기에서 부정 행위를 중지하도록 될 것이다. onPreferenceChange에서, 우리는하지
실제로 맛을 결합하지, 우리는 새로운 실행하는거야
위치 변경이 있는지 FetchWeatherTask.그렇지 않으면, 우리는 그냥 있어요
우리의 커서가 업데이트 할 수 있도록 우리의 CONTENT_URI에게 통지한다.
우리는 여전히 또 다른 일을 할 필요가 있습니다. ForecastFragment에서
우리 절약하기 위해 mLocation을 인스턴스 변수를 사용하여왔다
우리가 실제 onCreate 로더있을 때 우리가 얻는 바람직한 위치.
우리가 계획하고 왔기 때문에 우리는 그것을 해왔다
잠시 동안 이것을 사용한다. 는 다른 함수를 재정의하고 봅시다.로
우리는 어떻게 여부를 확인해야 onResume
우리의 위치가 변경되었습니다. 그래서 우리의 위치가 아닌 경우
null에 동일하다고 Utility.getPreferred 위치가 같지 않음
위치는 잘, 우리는 날씨를 업데이트 호출 할 수 있습니다. 어디 보자
무슨 일입니까? 당신은 이제 다시 변경을 참조하십시오. 당신은하지 않았습니다
뭔가를로드 할 필요가 없었기 때문에 그 하중을 참조하십시오.
그러나 우리는 뭔가 다른 설정을 변경 한 경우
그것은 배경을 상쾌하다. 글쎄, 그것은 발견
날씨를 업데이트하면 실제로 여기에 우리를 도와 않습니다.왜?
우리의 URI가 변경되지 않기 때문이다. 우리가하고있는 것을 기억하십시오
URI에 따라 모든 것. 우리가 정말 무엇이 필요
위해 우리의 로더를 재설정합니다. 그래서 어떻게
우리는 그것을해야합니까? 글쎄, 그것은 매우 간단합니다.
우리는 onActivityCreated에서했던 것과 마찬가지로 Google에있다
LoaderManager을 사용하고 있습니다.그래서이 아니라 updateWeather를 호출 어떤
우리는 실제로하려고하는 다른 통화입니다.
이 경우하지 initLoader하지만 restartLoader에서.
그것은 initLoader과 같은 매개 변수를 취합니다. 지금
는 다시 이것을 시도하자. 즉, 이미 잘 보인다.
판권 우리의 자신의 일기에 다시 변경하자
다시. 그리고 거기에 우리가있다.보시다시피,
우리는 장소에서 가도록 날씨가 변화하고있다
장소에, 우리는 아직 이것을 가지고
문제. 분명히, 우리는 여기에서 설정을 변경하면
그것은 아무것도 영향을주지 않기 때문에 우리는 그것을 수정해야합니다. 당신이 오는 곳이다.


46 - 자세한 구현
======================

지금 퀴즈 위해. 모든 심각성, 이것은 대부분있는
나는 당신에게 지금까지이 교훈을 준 복잡한 운동.난 당신이 갖고 싶습니다
상세을 구현하기 위해 커서 로더와 여러 텍스트 뷰를 사용하여 표시
위젯. 그리고 난 당신을 위해 몇 가지 팁을 가지고있다. 로더를 사용하십시오
하지 어댑터. 이것은 무엇을 의미하는 것일까 요? 글쎄, 그건 말이 있습니다.당신의 상세
그렇지 않기 때문에 뷰 목록이 포함되어 있지 않습니다
어댑터를 사용할 필요가 있지만, 당신은 아직 할 수
로더 패턴을 사용합니다. 로더 패턴이 자동으로 의지
CursorLoader와 URI의 변화를 관찰한다. 더
당신이 원하는 두 번째는 날짜를 전달합니다
당신의 의도. 날짜는 중요한 것입니다
당신이 그것을 통과해야 상세
적절한 콘텐츠 공급자를 조회한다.지금 당신이 할 수있는 기억
실제로 효용 함수에서 현재의 위치 설정을 가져옵니다. 이렇게
당신이 정말로 필요한 것은 날짜입니다. 나는 희망 수 있습니다.


47 - 저장 이미지와 바이너리 데이터
==================================

괜찮아. 지금 조금 즐거운 연습을 위해.우리는 저장하는 데 필요한 데이터의 경우
포함 된 이미지 및 기타 바이너리 데이터는 어떻게 것입니다
우리는 그것을 저장할? 우리는 삶을 둔다
데이터베이스의 데이터? 우리는 파일을 저장하거나
장치의 공용 폴더에? 또는
우리는 개인적으로 파일을 저장하는 것이다
폴더에는 데이터베이스의 위치를​​ 찾아?48 - 저장 이미지와 바이너리 데이터
==================================

은 이에 대해 이야기합시다. 솔직히, 정말 의존
당신의 데이터의 크기. 소량을 위해
바이너리 데이터, 매우 이진 데이터의 매우 소량
당신이 실제로 원시 데이터를 넣을 수 있습니다
데이터베이스. 가 물방울 종류가 있으며, 그들이 지원합니다
라든지됩니다 잘 작동한다.그러나 퍼팅 시작하면
데이터베이스에 큰 데이터 꽤 비효율적 인 가져옵니다.
그리고 당신은 더 많은 코드를 작성 끝난다.
그런데, 한 공용 폴더의 파일을 저장할
장치가 관계하고있는 데다 글쎄, 당신 있으면 잘지도 모른다
실제로 그 파일을 공유하고 싶었다.그러나 일반적으로 당신이 원하지 않는
다른 응용 프로그램과 파일들을 공유하고 있습니다. 이렇게이고 a에 저장
장치의 공용 폴더는 아주 좋은 생각이 아닙니다. 그러나
세 번째 옵션은 꽤 좋다. 내 파일을 저장할
개인 폴더 데이터베이스의 위치를​​ 참조한다. 그런데,
물론, 당신도 데이터베이스에 그들을 둘 필요가 있을지도 모릅니다
전혀.하지만 당신은 이렇게 많은 경우 기뻐요
당신은 그 질의 유형 중 하나를 수행해야합니다. 당신
에서 데이터베이스와 저장된 파일의 메타 데이터를 저장할 수 있습니다
개인 폴더. 이것은 Android가 갤러리에 무엇을 할 것인가이다.49 - 당신의 ContentProvider의 접근 가능하도록
===========================================

그것은 당신의 응용 프로그램의 콘텐츠 공급자를 만들기 위해 실제로 매우 간단합니다
타사 응용 프로그램이 유효하다. 키는 변경 될 수 있습니다
true 여기에 매니페스트 항목의 수출 플래그.
그런 간단한. 콘텐츠의 URI를 알고있는 모든 응용 프로그램
동일한 콘텐츠 수정하거나 액세스하는 데 사용할 수 있습니다
당신이 할 것.지금 당신의 감도에 따라
데이터는 특정 요구하여 그것을 보호 할 수 있습니다
읽거나 데이터베이스에 대한 쓰기 권한. 그렇다면, 당신
당신이 효과적으로 유일한 다른 사람에 대한 액세스를 제한 할 수 있습니다 원하는
작성한 응용 프로그램 또는 알고있는 타사 애플 리케이션에
권한 및 사용자는 이에 동의합니다.그럼 그냥 필요
구체적으로는 콘텐츠 공급자와 상호 작용하기 위해이 계약을 공표
URI와 열 이름입니다. 그리고 당신은 간단한 A PI를 만들었습니다
모든 데이터에 대한. 그리고 그런 간단한 당신이왔다
그냥 데이터를 위해 새로운 API를 만들었습니다.이것은 정확하게
기본 컨텐츠 제공 업체의 대부분이 사용하는 것과 동일한 접근,
연락처 데이터베이스, 미디어 스토어, 달력 및 통화 기록을 포함한다.


50 - 타사 콘텐츠 공급자
================================

중에 링크 기본 컨텐츠 제공자를 볼
강사는 다음 주.에 대한 이름은 무엇입니까
정적 상수는 콘텐츠의 URI를 찾기 위해 사용
오디오에 액세스하기위한 내부 데이터 저장소에 저장되어있는?


51 - 타사 컨텐츠 공급 업체
=========================================

이용 가능한 다른 콘텐츠 프로 바이더 수 있습니다
다른 위치에 저장된 미디어 유형을 사용한다.내부 데이터 저장소에 저장되어있는 오디오 미디어에 액세스하려면 사용하려는
INTERNAL_CONTENT_URI는 MediaStore.Audio.Media 클래스에서 제공합니다.


52 - 복고와 댄과 4 단원 요약
=====================================

그래서 라트, 우리는이 단원에서 배운?
>> 글쎄, 내가 쓰고 싶지 않은 것을 배웠다
데이터베이스와 콘텐츠 제공자. 당신은이 수업에서 무엇을 배웠습니까?
>> 그런데, J 단위 테스트는 위대하고 건물
우리의 응용 프로그램의 백엔드 프레임 워크가있다
일의 가장 빛나는.그것은 절대적으로 필수적인 부분입니다
더 나은 사용자 경험과 견고한 응용 프로그램을 만들 수 있습니다.
>> 나도 던가, 영어 악센트를 할 수 없다는 것을 배웠다.
>> [SOUND].다행히도, 당신은 캐서린 다시 환영 준비가 얻을 수 있습니다
우리는 조각에 우리의 활동을 산산조각 우 5 단원 사용을 위해
우리의 콘텐츠 제공자는 더 복잡한 UI를 이입하여 레이아웃을 구축
그들은 휴대 전화에서 수행하도록 태블릿에서뿐만 아니라 그 작업.>> 편리한 세그웨이처럼 보인다
Android 하드웨어의 역사와 진화에


53 - Storytime Android 하드웨어
===============================

모든 Android 발사 장치 넥서스 1 의지
항상 내 마음 속에 특별한 자리를 차지하고 있습니다. 그것은 아닙니다
내 첫 Android 장치에서 떨어져 뭔가를 데리고,
로 세계 안드로이드 출시 HTC G1 그
독특한 턱과 슬라이딩 키보드 또는 HTC 매직.첫
나는 개밥됐다 시험판 Android 휴대
나는 Google에 입사. 그리고 장치의 첫 번째 물결
우리는 2009 년에 Google IO에서 시작하는 모든 참가자를 주었다.
세계적인 현상에 흥미 롭다. 10 만 ~ 성장 활성화
12 월까지 30 만명 이상의 달의 날.
그것은 심각 방출에 의해 도움 받았다
모토로라 Droid. 난 아직도 사무실을 기억합니다
여기에 44를 구축하는 데 일정한 후렴에서 에코
각 장치가 다시 시작으로 이드.이드이었다
더 얇고, 더 높은 해상도의 첫 번째보다 강력한
이후 표준이되고있는 Android 장치. 그것을
또한 출시 버라이즌 여기에서 장치였다
U, S. 정말 안드로이드 홍수 킥오프
활성화. 하지만 이후 런던, 그리고 이드이었다
[UNKNOWN] 유일한 전화가 있었으므로, 그것은 결코 없었다
정말 디바이스 정말 사용.그러자 거기 있었다
넥서스 하나, 코드 네임 열정. 내가 느낀 첫 번째 장치였습니다
순수한 Android는 또한 우리는 우리와 가져온 전화했다
우리의 2010 년 Android 개발자 실험실 월드 투어에. 나에게
내 동료는 전세계를 여행. 7 도시
10 일. 2 만 이상의 개발자에 소개
프레젠테이션 방법과 무료 넥서스 1에 의해 안드로이드.그 결과 나는 많은 친구를 사귀었다
유럽​​ 전역과 전화 정확하게 얼마나 많은 상자를 배웠다
나는 스톡홀름에서 눈 드리프트간에 나를 수있는 경우
베를린의 얼어 붙은 도로. 이후 넥서스 S4와
5는 각각 만들기 위해 그것이 필요하게 개선하고있다
위대한 안드로이드 휴대 전화. 그리고 전세계 OEM 업체들은 가지고
다른 Android 장치 1000을 만들었습니다.모토로라에서 시작
알약에 Android의 공식 확장을 이끌고 줌 및 주요
넥서스 7과 10 그러나 그 방법이었다
다만 시작, 그 변경을 위해 길을 열었다
Android 모바일 [UNKNOWN] 서쪽, 뭘 할 수 있는지에 성장하고
TV, 자동차에 휴대폰이나 태블릿에서 무언가 두뇌,
안드로이드웨어 같은 경우 착용. 그것은 무엇이 올 것인지 아는 것은 불가능하다
다음. 알고 있습니까? 아마 다음 Android 장치는 안드로이드 자체입니다.
